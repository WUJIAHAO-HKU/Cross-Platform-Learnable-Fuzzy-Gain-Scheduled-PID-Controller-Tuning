function out = pd_tuning_helper(action, varargin)
% PD_TUNING_HELPER  Utility functions for Franka PD gain estimation & Lyapunov metrics.
%   out = pd_tuning_helper('suggest', 'KpBase', KpBaseVector, 'Zeta', 0.7)
%   out = pd_tuning_helper('lyapunov', 'q', q, 'qd', qd, 'q_ref', q_ref, 'qd_ref', qd_ref,
%                           'Q', Q, 'R', R)
%
% Actions:
%   'suggest'  : Provide Kd suggestion for given Kp and target damping ratio ζ.
%   'lyapunov' : Compute V and dVdt approximate (finite difference) for logging.
%
% Name-Value (suggest):
%   KpBase : 1x7 vector of proportional gains (diag entries)
%   InertiaApprox : 1x7 approx diagonal inertia (default rough Franka guess)
%   Zeta : damping ratio target (default 0.7)
%
% Output (suggest): struct with fields Kp, Kd_suggested, natural_freq, zeta
%
% Name-Value (lyapunov):
%   q, qd, q_ref, qd_ref : column vectors (7x1)
%   Q, R : positive definite weighting matrices / diag vectors
%   dt : finite difference step (default 0.001)
%
% Output (lyapunov): struct with fields V, dVdt_est, e, edot
%
% NOTE: This is an analytical helper; ensure consistency of units.
%
% Author: autogenerated

action = lower(action);

switch action
    case 'suggest'
        p = inputParser;
        addParameter(p,'KpBase',[],@(x)isnumeric(x));
        addParameter(p,'InertiaApprox',[0.6 0.6 0.35 0.25 0.15 0.1 0.05],@(x)isnumeric(x));
        addParameter(p,'Zeta',0.7,@(x)isnumeric(x)&&isscalar(x));
        parse(p,varargin{:});
        opt = p.Results;
        Kp = opt.KpBase(:)';
        if isempty(Kp)
            error('Provide KpBase');
        end
        J = opt.InertiaApprox(:)';
        if numel(J) ~= numel(Kp)
            error('InertiaApprox length mismatch');
        end
        % Natural frequency estimation w_n = sqrt(Kp / J)
        wn = sqrt(Kp ./ J);
        Kd = 2*opt.Zeta .* sqrt(Kp .* J); % critical scaled by ζ
        out = struct('Kp',Kp,'Kd_suggested',Kd,'natural_freq',wn,'zeta',opt.Zeta);

    case 'lyapunov'
        p = inputParser;
        addParameter(p,'q',[],@(x)isnumeric(x));
        addParameter(p,'qd',[],@(x)isnumeric(x));
        addParameter(p,'q_ref',[],@(x)isnumeric(x));
        addParameter(p,'qd_ref',[],@(x)isnumeric(x));
        addParameter(p,'Q',[],@(x)isnumeric(x));
        addParameter(p,'R',[],@(x)isnumeric(x));
        addParameter(p,'dt',0.001,@(x)isnumeric(x)&&isscalar(x));
        parse(p,varargin{:});
        o = p.Results;
        e = (o.q_ref - o.q);
        if isempty(o.qd_ref); o.qd_ref = zeros(size(o.q)); end
        edot = (o.qd_ref - o.qd);
        Q = diagOrMatrix(o.Q, numel(e));
        R = diagOrMatrix(o.R, numel(e));
        V = e' * Q * e + edot' * R * edot;
        % crude finite difference if previous stored globally (persistent)
        persistent prevV
        persistent prevT
        if isempty(prevV)
            prevV = V; prevT = 0; dVdt_est = 0;
        else
            dVdt_est = (V - prevV)/o.dt;
            prevV = V; prevT = prevT + o.dt;
        end
        out = struct('V',V,'dVdt_est',dVdt_est,'e',e,'edot',edot);

    otherwise
        error('Unknown action %s', action);
end
end

function M = diagOrMatrix(x, n)
    if isempty(x)
        M = eye(n);
    elseif isvector(x)
        if numel(x) ~= n
            error('Vector length mismatch for diag');
        end
        M = diag(x);
    else
        M = x;
    end
end
