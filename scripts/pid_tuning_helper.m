function out = pid_tuning_helper(action, varargin)
% PID_TUNING_HELPER  Helper utilities for extending existing PD gains to PID.
%   out = pid_tuning_helper('suggest', 'KpBase', KpVector, 'InertiaApprox', JVector,
%                            'Zeta', 0.7, 'RiseTime', [], 'Bandwidth', [], 'KiMethod','zn')
%   out = pid_tuning_helper('analyze', 'q', q, 'qd', qd, 'q_ref', q_ref, 'qd_ref', qd_ref,
%                            'Kp',Kp,'Kd',Kd,'Ki',Ki,'Dt',0.001)
%
% Actions:
%   'suggest' : Provide Kd and Ki suggestions for each joint based on provided Kp and target dynamics.
%               Ki can be chosen by several methods: 'none','zn','pole','area'.
%   'analyze' : Compute basic closed-loop indicators given instantaneous error signals.
%
% Name-Value (suggest):
%   KpBase        : 1xN proportional gains (required)
%   InertiaApprox : 1xN approximate diagonal inertia terms (default heuristic for Franka)
%   Zeta          : Desired damping ratio for PD pair (default 0.7)
%   RiseTime      : (Optional) target 10-90%% rise time (s); if given overrides Bandwidth.
%   Bandwidth     : (Optional) target natural frequency (rad/s) ~ bandwidth; if omitted derived from Kp & inertia.
%   KiMethod      : 'none' | 'zn' (Ziegler-Nichols style) | 'pole' (add real pole) | 'area' (integral of error heuristic)
%   ExtraPoleFac  : For KiMethod='pole', integrator pole placed at wn/ExtraPoleFac (default 4)
%   MaxKiScale    : Safety cap scaling relative to Kp (default 0.2 => Ki <= 0.2*Kp)
%
% Output (suggest): struct with fields
%   Kp, Kd_suggested, Ki_suggested, wn, zeta, method
%
% Name-Value (analyze):
%   q, qd, q_ref, qd_ref : joint position/velocity & references
%   Kp, Kd, Ki           : gains (scalar or vectors)
%   Dt                  : sample time (s)
%
% Output (analyze): struct with fields e, edot, e_int_est, control_pd, control_pid
%
% NOTE: This is analytical; validate in simulation.
%
% Author: autogenerated helper (PID extension)

action = lower(action);

switch action
    case 'suggest'
        p = inputParser;
        addParameter(p,'KpBase',[],@(x)isnumeric(x));
        addParameter(p,'InertiaApprox',[0.6 0.6 0.35 0.25 0.15 0.1 0.05],@(x)isnumeric(x));
        addParameter(p,'Zeta',0.7,@(x)isnumeric(x)&&isscalar(x));
        addParameter(p,'RiseTime',[],@(x)isnumeric(x));
        addParameter(p,'Bandwidth',[],@(x)isnumeric(x));
        addParameter(p,'KiMethod','zn',@(x)ischar(x)||isstring(x));
        addParameter(p,'ExtraPoleFac',4,@(x)isnumeric(x)&&isscalar(x)&&x>0);
        addParameter(p,'MaxKiScale',0.2,@(x)isnumeric(x)&&isscalar(x)&&x>0);
        parse(p,varargin{:});
        o = p.Results;
        if isempty(o.KpBase); error('Provide KpBase'); end
        Kp = o.KpBase(:)'; J = o.InertiaApprox(:)';
        if numel(J) ~= numel(Kp); error('InertiaApprox length mismatch'); end
        % Natural frequency: if Bandwidth given use it; else derive from Kp/J
        if ~isempty(o.Bandwidth)
            wn = o.Bandwidth(:)';
            if numel(wn)==1; wn = repmat(wn,1,numel(Kp)); end
        else
            wn = sqrt(Kp ./ J); % from second-order approx
            if ~isempty(o.RiseTime)
                % 10-90% rise time Tr ≈ 1.8 / wn (for ζ≈0.7)
                wn = 1.8 ./ o.RiseTime;
            end
        end
        % D term for critical damping scaled by ζ
        Kd = 2*o.Zeta .* sqrt(Kp .* J);
        % Ki selection
        Ki = zeros(size(Kp));
        method = lower(o.KiMethod);
        switch method
            case {'none','off'}
                % Ki = 0
            case {'zn','ziegler','ziegler-nichols'}
                % Approx: Ki ≈ Kp / (Ti) with Ti ≈ 2*Td (classic ZN closed-loop). Td = Kd/Kp.
                Td = Kd ./ Kp; Ti = 2*Td; Ki = Kp ./ max(Ti,1e-6);
            case 'pole'
                % Place closed-loop zero from integral at s = -wn/ExtraPoleFac.
                % For transfer (Ki/s) added, approximate Ki ≈ wn/ExtraPoleFac * Kp.
                Ki = (wn / o.ExtraPoleFac) .* Kp ./ max(Kp,1e-9); % simplifies to wn/ExtraPoleFac * 1
                Ki = wn / o.ExtraPoleFac; % simpler heuristic
            case 'area'
                % Heuristic: Ki = α * Kp; α chosen so integral settles error within ~ (1/α*wn)
                alpha = 0.05; Ki = alpha * Kp;
            otherwise
                error('Unknown KiMethod %s', o.KiMethod);
        end
        % Safety cap
        Ki = min(Ki, o.MaxKiScale * Kp);
        out = struct('Kp',Kp,'Kd_suggested',Kd,'Ki_suggested',Ki,'wn',wn,'zeta',o.Zeta,'method',method);

    case 'analyze'
        p = inputParser;
        addParameter(p,'q',[],@(x)isnumeric(x));
        addParameter(p,'qd',[],@(x)isnumeric(x));
        addParameter(p,'q_ref',[],@(x)isnumeric(x));
        addParameter(p,'qd_ref',[],@(x)isnumeric(x));
        addParameter(p,'Kp',[],@(x)isnumeric(x));
        addParameter(p,'Kd',[],@(x)isnumeric(x));
        addParameter(p,'Ki',[],@(x)isnumeric(x));
        addParameter(p,'Dt',0.001,@(x)isnumeric(x)&&isscalar(x));
        parse(p,varargin{:});
        r = p.Results;
        e = (r.q_ref - r.q);
        edot = (r.qd_ref - r.qd);
        persistent e_int_prev
        if isempty(e_int_prev) || numel(e_int_prev)~=numel(e); e_int_prev = zeros(size(e)); end
        e_int = e_int_prev + e * r.Dt;
        e_int_prev = e_int;
        control_pd = r.Kp(:).*e + r.Kd(:).*edot;
        if isempty(r.Ki); r.Ki = zeros(size(r.Kp)); end
        control_pid = control_pd + r.Ki(:).*e_int;
        out = struct('e',e,'edot',edot,'e_int_est',e_int,'control_pd',control_pd,'control_pid',control_pid);
    otherwise
        error('Unknown action %s', action);
end
end
