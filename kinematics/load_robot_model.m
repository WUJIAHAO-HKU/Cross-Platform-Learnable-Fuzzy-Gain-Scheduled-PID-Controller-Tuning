function robotInfo = load_robot_model(robotType, varargin)
% LOAD_ROBOT_MODEL  Unified loader for different robot arm variants (Franka, eDO, etc.).
%   robotInfo = load_robot_model('franka')
%   robotInfo = load_robot_model('edo','URDFPath','开源机器人urdf/eDO_description/robots/edo_sim.urdf')
%
% Optional Name-Value:
%   'URDFPath'      : path to URDF file (for URDF-based robots)
%   'UseToolbox'    : true/false (try Robotics System Toolbox import) (default: true)
%   'AddToolLength' : numeric (tool z extension) default 0
%
% Output robotInfo fields (depending on type):
%   .type            : 'franka' | 'edo'
%   .dof             : number of actuated joints
%   .nameList        : joint names (if URDF)
%   .urdfAvailable   : logical
%   .robotObj        : rigidBodyTree (if imported)
%   .fkHandle(q)     : function returning T (4x4)
%   .jacobianHandle(q): function returning geometric Jacobian (6 x dof)
%   .limits          : joint limits [dof x 2]
%   .referenceBuilder: function struct for trajectory building (optional placeholder)
%
% This abstraction lets higher layers stay agnostic to specific arm geometry.
%
% NOTE: For 'franka' uses internal approximate DH (forwardKinematics_franka / computeJacobian_franka).
%       For 'edo' will attempt URDF import; if toolbox not present, minimal error issued.
%
% Author: autogenerated.

p = inputParser;
addParameter(p,'URDFPath','',@ischar);
addParameter(p,'UseToolbox',true,@islogical);
addParameter(p,'AddToolLength',0,@isnumeric);
parse(p,varargin{:});
opt = p.Results;

robotType = lower(robotType);
robotInfo = struct();
robotInfo.type = robotType;
robotInfo.urdfAvailable = false;
robotInfo.robotObj = [];
robotInfo.referenceBuilder = [];

switch robotType
    case 'franka'
        robotInfo.dof = 7;
        robotInfo.fkHandle = @(q) forwardKinematics_franka(q);
        robotInfo.jacobianHandle = @(q) computeJacobian_franka(q);
        % Approximate limits (rad)
        robotInfo.limits = [
            -2.9  2.9;
            -1.76 1.76;
            -2.9  2.9;
            -3.07 -0.07;
            -2.9  2.9;
            -0.01 3.75;
            -2.9  2.9];
        robotInfo.nameList = arrayfun(@(i) sprintf('joint%d',i),1:7,'UniformOutput',false);

    case {'edo','e-do','edo6'}
        % eDO is typically a 6-DOF arm
        robotInfo.dof = 6;
        robotInfo.limits = repmat([-pi pi],6,1); % Placeholder; refine if URDF parsed
        robotInfo.nameList = {};
        if opt.UseToolbox
            hasTB = localHasRobotics();
            if hasTB
                urdfPath = opt.URDFPath;
                if isempty(urdfPath)
                    % Try default relative path
                    guess = fullfile(pwd,'开源机器人urdf','eDO_description','robots','edo_sim.urdf');
                    if exist(guess,'file'); urdfPath = guess; end
                end
                if exist(urdfPath,'file')
                    try
                        rb = importrobot(urdfPath,'DataFormat','row','MaxNumBodies',100);
                        robotInfo.robotObj = rb;
                        robotInfo.urdfAvailable = true;
                        % Extract joint names & limits
                        jNames = {};
                        lims = [];
                        bodies = rb.Bodies;
                        for i=1:numel(bodies)
                            j = bodies{i}.Joint;
                            if j.JointType == "revolute"
                                jNames{end+1} = j.Name; %#ok<AGROW>
                                lims(end+1,:) = double(j.PositionLimits); %#ok<AGROW>
                            end
                        end
                        robotInfo.nameList = jNames;
                        if size(lims,1) == robotInfo.dof; robotInfo.limits = lims; end
                        robotInfo.fkHandle = @(q) localURDFFK(rb,q,opt.AddToolLength);
                        robotInfo.jacobianHandle = @(q) localURDFJac(rb,q);
                    catch ME
                        warning('URDF import failed: %s', ME.message);
                        robotInfo.fkHandle = @(q) error('FK unavailable for eDO (import failed).');
                        robotInfo.jacobianHandle = @(q) error('Jacobian unavailable.');
                    end
                else
                    warning('URDF file not found. Provide path via URDFPath.');
                    robotInfo.fkHandle = @(q) error('FK unavailable (no URDF).');
                    robotInfo.jacobianHandle = @(q) error('Jacobian unavailable.');
                end
            else
                warning('Robotics System Toolbox not detected; cannot import eDO URDF.');
                robotInfo.fkHandle = @(q) error('FK unavailable (no toolbox).');
                robotInfo.jacobianHandle = @(q) error('Jacobian unavailable.');
            end
        else
            warning('UseToolbox=false and no internal DH model for eDO.');
            robotInfo.fkHandle = @(q) error('FK unavailable (disabled).');
            robotInfo.jacobianHandle = @(q) error('Jacobian unavailable.');
        end

    otherwise
        error('Unknown robotType: %s', robotType);
end

end

function T = localURDFFK(rb, q, toolExt)
    if size(q,1)==1; qRow = q; else; qRow = q'; end
    base = rb.BaseName; % often 'base_link'
    % Find last body with a revolute or fixed before tool
    endName = rb.BodyNames{end};
    T = getTransform(rb, qRow, endName);
    if toolExt>0
        T = T * trotz(0) * transl(0,0,toolExt); %#ok<NOPRT>
    end
end

function J = localURDFJac(rb, q)
    if size(q,1)==1; qRow = q; else; qRow = q'; end
    endName = rb.BodyNames{end};
    try
        [J,~] = geometricJacobian(rb, qRow, endName);
    catch
        J = nan(6, numel(q));
    end
end

function yes = localHasRobotics()
    try
        v = ver; names = {v.Name};
        yes = any(contains(lower(names),'robotics'));
    catch
        yes = false;
    end
end
